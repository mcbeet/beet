__all__ = [
    "Project",
    "Context",
    "Generator",
    "GeneratorSpec",
    "GeneratorError",
    "GeneratorImportError",
]


import sys
import json
from datetime import datetime
from contextlib import contextmanager
from collections import deque
from copy import deepcopy
from dataclasses import dataclass
from pathlib import Path
from typing import ClassVar, Protocol, NamedTuple, Union, Sequence, Iterator, Set, Deque

from .assets import ResourcePack
from .data import DataPack
from .cache import MultiCache
from .utils import FileSystemPath, extra_field, import_from_string


class Generator(Protocol):
    def __call__(self, ctx: "Context"):
        pass


GeneratorSpec = Union[Generator, str]


class GeneratorError(Exception):
    pass


class GeneratorImportError(GeneratorError):
    pass


class Context(NamedTuple):
    directory: Path
    output_directory: Path
    meta: dict
    cache: MultiCache
    assets: ResourcePack
    data: DataPack
    queue: Deque[GeneratorSpec]
    applied_generators: Set[Generator]
    default_generator: str
    current_time: datetime

    def apply(self, generator: GeneratorSpec):
        try:
            func: Generator = (
                import_from_string(generator, default_member=self.default_generator)
                if isinstance(generator, str)
                else generator
            )
        except GeneratorError:
            raise
        except Exception as exc:
            raise GeneratorImportError(generator) from exc

        if func in self.applied_generators:
            return

        self.applied_generators.add(func)

        try:
            func(self)
        except GeneratorError:
            raise
        except Exception as exc:
            raise GeneratorError(func) from exc.with_traceback(
                getattr(exc.__traceback__, "tb_next", exc.__traceback__)
            )


@dataclass
class Project:
    name: str
    description: str
    author: str
    version: str

    directory: FileSystemPath
    generators: Sequence[GeneratorSpec]
    meta: dict

    output_directory: str = extra_field(default="generated")

    resource_pack_name: str = extra_field(default="{name} Resource Pack")
    resource_pack_format: int = extra_field(default=ResourcePack.latest_pack_format)
    resource_pack_zipped: bool = extra_field(default=False)
    resource_pack_description: str = extra_field(
        default="{description}\n\nVersion {version}\nBy {author}",
    )

    data_pack_name: str = extra_field(default="{name}")
    data_pack_format: int = extra_field(default=DataPack.latest_pack_format)
    data_pack_zipped: bool = extra_field(default=False)
    data_pack_description: str = extra_field(
        default="{description}\n\nVersion {version}\nBy {author}",
    )

    cache_directory: ClassVar[str] = ".beet_cache"
    default_generator: ClassVar[str] = "default_generator"

    @classmethod
    def from_config(cls, config_file: FileSystemPath) -> "Project":
        config_path = Path(config_file).resolve()

        config = json.loads(config_path.read_text())
        meta = config.get("meta", {})

        return cls(
            name=config.get("name", "Untitled"),
            description=config.get("description", "Generated by Beet"),
            author=config.get("author", "Unknown"),
            version=config.get("version", "0.0.0"),
            directory=config_path.parent,
            generators=config.get("generators", []),
            meta=meta,
            **{
                key: value
                for key in [
                    "output_directory",
                    "resource_pack_name",
                    "resource_pack_format",
                    "resource_pack_zipped",
                    "resource_pack_description",
                    "data_pack_name",
                    "data_pack_format",
                    "data_pack_zipped",
                    "data_pack_description",
                ]
                if (value := meta.get(key))
            },
        )

    @contextmanager
    def context(self) -> Iterator[Context]:
        project_path = Path(self.directory).resolve()
        path_entry = str(project_path)

        output_directory = project_path / self.output_directory
        output_directory.mkdir(parents=True, exist_ok=True)

        variables = {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "version": self.version,
        }

        sys.path.append(path_entry)

        try:
            with MultiCache(project_path / self.cache_directory) as cache:
                yield Context(
                    directory=project_path,
                    output_directory=output_directory,
                    meta=deepcopy(self.meta),
                    cache=cache,
                    assets=ResourcePack(
                        self.resource_pack_name.format_map(variables),
                        self.resource_pack_description.format_map(variables),
                        self.resource_pack_format,
                        self.resource_pack_zipped,
                    ),
                    data=DataPack(
                        self.data_pack_name.format_map(variables),
                        self.data_pack_description.format_map(variables),
                        self.data_pack_format,
                        self.data_pack_zipped,
                    ),
                    queue=deque(self.generators),
                    applied_generators=set(),
                    default_generator=self.default_generator,
                    current_time=datetime.now(),
                )
        finally:
            sys.path.remove(path_entry)

            imported_modules = [
                name
                for name, module in sys.modules.items()
                if (filename := getattr(module, "__file__", None))
                and filename.startswith(path_entry)
            ]

            for name in imported_modules:
                del sys.modules[name]

    def build(self) -> Context:
        with self.context() as ctx:
            while ctx.queue:
                ctx.apply(ctx.queue.popleft())
            return ctx
